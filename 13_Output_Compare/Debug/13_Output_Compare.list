
13_Output_Compare.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000198  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00000194  08000198  08000198  00001198  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000000  0800032c  08000334  00001334  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .ARM.extab    00000000  0800032c  0800032c  00001334  2**0
                  CONTENTS, READONLY
  4 .ARM          00000000  0800032c  0800032c  00001334  2**0
                  CONTENTS, READONLY
  5 .preinit_array 00000000  0800032c  08000334  00001334  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0800032c  0800032c  0000132c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  08000330  08000330  00001330  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000000  20000000  20000000  00001334  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          0000001c  20000000  08000334  00002000  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  2000001c  08000334  0000201c  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00001334  2**0
                  CONTENTS, READONLY
 12 .debug_info   000004d1  00000000  00000000  00001364  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00000135  00000000  00000000  00001835  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00000070  00000000  00000000  00001970  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_rnglists 00000046  00000000  00000000  000019e0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  0000ea22  00000000  00000000  00001a26  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   00000ce2  00000000  00000000  00010448  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    0005397a  00000000  00000000  0001112a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000043  00000000  00000000  00064aa4  2**0
                  CONTENTS, READONLY
 20 .debug_frame  000000a8  00000000  00000000  00064ae8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 00000052  00000000  00000000  00064b90  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000198 <__do_global_dtors_aux>:
 8000198:	b510      	push	{r4, lr}
 800019a:	4c05      	ldr	r4, [pc, #20]	@ (80001b0 <__do_global_dtors_aux+0x18>)
 800019c:	7823      	ldrb	r3, [r4, #0]
 800019e:	b933      	cbnz	r3, 80001ae <__do_global_dtors_aux+0x16>
 80001a0:	4b04      	ldr	r3, [pc, #16]	@ (80001b4 <__do_global_dtors_aux+0x1c>)
 80001a2:	b113      	cbz	r3, 80001aa <__do_global_dtors_aux+0x12>
 80001a4:	4804      	ldr	r0, [pc, #16]	@ (80001b8 <__do_global_dtors_aux+0x20>)
 80001a6:	f3af 8000 	nop.w
 80001aa:	2301      	movs	r3, #1
 80001ac:	7023      	strb	r3, [r4, #0]
 80001ae:	bd10      	pop	{r4, pc}
 80001b0:	20000000 	.word	0x20000000
 80001b4:	00000000 	.word	0x00000000
 80001b8:	08000314 	.word	0x08000314

080001bc <frame_dummy>:
 80001bc:	b508      	push	{r3, lr}
 80001be:	4b03      	ldr	r3, [pc, #12]	@ (80001cc <frame_dummy+0x10>)
 80001c0:	b11b      	cbz	r3, 80001ca <frame_dummy+0xe>
 80001c2:	4903      	ldr	r1, [pc, #12]	@ (80001d0 <frame_dummy+0x14>)
 80001c4:	4803      	ldr	r0, [pc, #12]	@ (80001d4 <frame_dummy+0x18>)
 80001c6:	f3af 8000 	nop.w
 80001ca:	bd08      	pop	{r3, pc}
 80001cc:	00000000 	.word	0x00000000
 80001d0:	20000004 	.word	0x20000004
 80001d4:	08000314 	.word	0x08000314

080001d8 <main>:
#include "uart.h"
#include "timer.h"



int main (void){
 80001d8:	b580      	push	{r7, lr}
 80001da:	af00      	add	r7, sp, #0
	tim2_pa5_output_compare();
 80001dc:	f000 f804 	bl	80001e8 <tim2_pa5_output_compare>
 80001e0:	2300      	movs	r3, #0

}
 80001e2:	4618      	mov	r0, r3
 80001e4:	bd80      	pop	{r7, pc}
	...

080001e8 <tim2_pa5_output_compare>:
	/*Enable timer - We need to locate a particular bit inside a time control register.In reference manual go to TIMx_CR1. Bit 0 CEN enables the timer*/
	TIM2->CR1 = CR1_CEN;

}

void tim2_pa5_output_compare(void){
 80001e8:	b480      	push	{r7}
 80001ea:	af00      	add	r7, sp, #0

	/*Enable clock access to GPIOA*/
	RCC->AHB1ENR |= GPIOAEN;
 80001ec:	4b20      	ldr	r3, [pc, #128]	@ (8000270 <tim2_pa5_output_compare+0x88>)
 80001ee:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80001f0:	4a1f      	ldr	r2, [pc, #124]	@ (8000270 <tim2_pa5_output_compare+0x88>)
 80001f2:	f043 0301 	orr.w	r3, r3, #1
 80001f6:	6313      	str	r3, [r2, #48]	@ 0x30
	/*Set PA5 mode to alternate function - PA5 occupies bit 10 and 11 in the mode register. To set alternate function mode,the first bit(bit 10) has to be set to 0 and second bit(bit 11) has to be set to 1.*/
	GPIOA->MODER &=~(1U<<10);  //going to mode register to set PA5 as an output pin(setting bit 10 to 0)
 80001f8:	4b1e      	ldr	r3, [pc, #120]	@ (8000274 <tim2_pa5_output_compare+0x8c>)
 80001fa:	681b      	ldr	r3, [r3, #0]
 80001fc:	4a1d      	ldr	r2, [pc, #116]	@ (8000274 <tim2_pa5_output_compare+0x8c>)
 80001fe:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
 8000202:	6013      	str	r3, [r2, #0]
	GPIOA->MODER |= (1U<<11);  //set bit 11 to 1  NOTE: 11-10 -->1-0: Alternate Function Mode
 8000204:	4b1b      	ldr	r3, [pc, #108]	@ (8000274 <tim2_pa5_output_compare+0x8c>)
 8000206:	681b      	ldr	r3, [r3, #0]
 8000208:	4a1a      	ldr	r2, [pc, #104]	@ (8000274 <tim2_pa5_output_compare+0x8c>)
 800020a:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 800020e:	6013      	str	r3, [r2, #0]

	/*Set PA5 alternate function type to TIM2_CH1 - This is AF01( Go to datasheet , go to Table 9 - Alternate function mapping. For PA5 we have TIM2_CH1. */
    GPIOA->AFR[0] |= (1U<<20); //because this is pin five, we need to use the alternate function register low. Therefore we're looking for AFRL5(in GPIOx_AFRL Register).
 8000210:	4b18      	ldr	r3, [pc, #96]	@ (8000274 <tim2_pa5_output_compare+0x8c>)
 8000212:	6a1b      	ldr	r3, [r3, #32]
 8000214:	4a17      	ldr	r2, [pc, #92]	@ (8000274 <tim2_pa5_output_compare+0x8c>)
 8000216:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 800021a:	6213      	str	r3, [r2, #32]
                               //It occupies bit 20 to bit 23, AF01 means set one to the first bit,means bit 20 has to be 1. [0001:AF1].Also symbolic name can be created as AFR_TIM (1U<<20)


    /*Enable clock access tim2*/
	RCC->APB1ENR |=TIM2EN;
 800021c:	4b14      	ldr	r3, [pc, #80]	@ (8000270 <tim2_pa5_output_compare+0x88>)
 800021e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8000220:	4a13      	ldr	r2, [pc, #76]	@ (8000270 <tim2_pa5_output_compare+0x88>)
 8000222:	f043 0301 	orr.w	r3, r3, #1
 8000226:	6413      	str	r3, [r2, #64]	@ 0x40

    /*Set prescaler value - To set the prescaler value,we put this inside the prescaler register.Default system clock is 16MHz and this is same clock for the APB1 bus,
    because we've not configured the clock tree yet.We want to reduce this clock to 1hz,we want the timer to end up with one hz ,essentially.*/
	TIM2->PSC = 1600-1;   //1600 because we count from 0 , we'll say -1 here. Think of this having a 16MHz divided by 1600-->16 000 000/1600 = 10 000
 8000228:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 800022c:	f240 623f 	movw	r2, #1599	@ 0x63f
 8000230:	629a      	str	r2, [r3, #40]	@ 0x28

	/*Set auto-reload value*/
	TIM2->ARR =10000-1; //we come from zero, we say -1.Think of it as 10000/10000=1.Therefore we end up with 1hz
 8000232:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000236:	f242 720f 	movw	r2, #9999	@ 0x270f
 800023a:	62da      	str	r2, [r3, #44]	@ 0x2c

	/*Set output compare toggle mode - Go to reference manual, go to TIMx_CCMR(we will use CCMR1 here) register.We are interested in OC1M(Output Compare 1 Mode)
	 because we are using channel 1 of this timer.If we were to use channel2 , we got to use OC2M.If we set bit 6-5-4 to 0-0-1 = set channel to active level on match.
	 If we want active level on match, we set the first bit to 1 and the other two bits to 0. If we set it to 0-1-1 = toggle i.e. set first two bit(bit 4&5) to 1 and third to 0. */
	TIM2->CCMR1 = (1U<<4)| (1U<<5);  //bit 4&5 set to 1 .Also we can create symbol for these bits as OC_TOGGLE = (1U<<4) | (1U<<5)
 800023c:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000240:	2230      	movs	r2, #48	@ 0x30
 8000242:	619a      	str	r2, [r3, #24]

	/*Enable timer2 channel1 in compare mode - Go to TIMx_CCER(capture/compare enable register).There is another mode known as input capture mode and we use these same registers to
	 configure the input capture mode as well.Bit 0 is capture/compare output enable,1 means capture enabled.we're using bit zero because we are using channel1. */
    TIM2->CCER |= CCER_CC1E;
 8000244:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000248:	6a1b      	ldr	r3, [r3, #32]
 800024a:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 800024e:	f043 0301 	orr.w	r3, r3, #1
 8000252:	6213      	str	r3, [r2, #32]

	/*Clear counter*/
	TIM2->CNT =0;
 8000254:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000258:	2200      	movs	r2, #0
 800025a:	625a      	str	r2, [r3, #36]	@ 0x24
	/*Enable timer - We need to locate a particular bit inside a time control register.In reference manual go to TIMx_CR1. Bit 0 CEN enables the timer*/
	TIM2->CR1 = CR1_CEN;
 800025c:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000260:	2201      	movs	r2, #1
 8000262:	601a      	str	r2, [r3, #0]

}
 8000264:	bf00      	nop
 8000266:	46bd      	mov	sp, r7
 8000268:	f85d 7b04 	ldr.w	r7, [sp], #4
 800026c:	4770      	bx	lr
 800026e:	bf00      	nop
 8000270:	40023800 	.word	0x40023800
 8000274:	40020000 	.word	0x40020000

08000278 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8000278:	480d      	ldr	r0, [pc, #52]	@ (80002b0 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 800027a:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
 800027c:	f3af 8000 	nop.w

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8000280:	480c      	ldr	r0, [pc, #48]	@ (80002b4 <LoopForever+0x6>)
  ldr r1, =_edata
 8000282:	490d      	ldr	r1, [pc, #52]	@ (80002b8 <LoopForever+0xa>)
  ldr r2, =_sidata
 8000284:	4a0d      	ldr	r2, [pc, #52]	@ (80002bc <LoopForever+0xe>)
  movs r3, #0
 8000286:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8000288:	e002      	b.n	8000290 <LoopCopyDataInit>

0800028a <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 800028a:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 800028c:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 800028e:	3304      	adds	r3, #4

08000290 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8000290:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8000292:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8000294:	d3f9      	bcc.n	800028a <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8000296:	4a0a      	ldr	r2, [pc, #40]	@ (80002c0 <LoopForever+0x12>)
  ldr r4, =_ebss
 8000298:	4c0a      	ldr	r4, [pc, #40]	@ (80002c4 <LoopForever+0x16>)
  movs r3, #0
 800029a:	2300      	movs	r3, #0
  b LoopFillZerobss
 800029c:	e001      	b.n	80002a2 <LoopFillZerobss>

0800029e <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 800029e:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 80002a0:	3204      	adds	r2, #4

080002a2 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 80002a2:	42a2      	cmp	r2, r4
  bcc FillZerobss
 80002a4:	d3fb      	bcc.n	800029e <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 80002a6:	f000 f811 	bl	80002cc <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 80002aa:	f7ff ff95 	bl	80001d8 <main>

080002ae <LoopForever>:

LoopForever:
  b LoopForever
 80002ae:	e7fe      	b.n	80002ae <LoopForever>
  ldr   r0, =_estack
 80002b0:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 80002b4:	20000000 	.word	0x20000000
  ldr r1, =_edata
 80002b8:	20000000 	.word	0x20000000
  ldr r2, =_sidata
 80002bc:	08000334 	.word	0x08000334
  ldr r2, =_sbss
 80002c0:	20000000 	.word	0x20000000
  ldr r4, =_ebss
 80002c4:	2000001c 	.word	0x2000001c

080002c8 <ADC_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 80002c8:	e7fe      	b.n	80002c8 <ADC_IRQHandler>
	...

080002cc <__libc_init_array>:
 80002cc:	b570      	push	{r4, r5, r6, lr}
 80002ce:	4d0d      	ldr	r5, [pc, #52]	@ (8000304 <__libc_init_array+0x38>)
 80002d0:	4c0d      	ldr	r4, [pc, #52]	@ (8000308 <__libc_init_array+0x3c>)
 80002d2:	1b64      	subs	r4, r4, r5
 80002d4:	10a4      	asrs	r4, r4, #2
 80002d6:	2600      	movs	r6, #0
 80002d8:	42a6      	cmp	r6, r4
 80002da:	d109      	bne.n	80002f0 <__libc_init_array+0x24>
 80002dc:	4d0b      	ldr	r5, [pc, #44]	@ (800030c <__libc_init_array+0x40>)
 80002de:	4c0c      	ldr	r4, [pc, #48]	@ (8000310 <__libc_init_array+0x44>)
 80002e0:	f000 f818 	bl	8000314 <_init>
 80002e4:	1b64      	subs	r4, r4, r5
 80002e6:	10a4      	asrs	r4, r4, #2
 80002e8:	2600      	movs	r6, #0
 80002ea:	42a6      	cmp	r6, r4
 80002ec:	d105      	bne.n	80002fa <__libc_init_array+0x2e>
 80002ee:	bd70      	pop	{r4, r5, r6, pc}
 80002f0:	f855 3b04 	ldr.w	r3, [r5], #4
 80002f4:	4798      	blx	r3
 80002f6:	3601      	adds	r6, #1
 80002f8:	e7ee      	b.n	80002d8 <__libc_init_array+0xc>
 80002fa:	f855 3b04 	ldr.w	r3, [r5], #4
 80002fe:	4798      	blx	r3
 8000300:	3601      	adds	r6, #1
 8000302:	e7f2      	b.n	80002ea <__libc_init_array+0x1e>
 8000304:	0800032c 	.word	0x0800032c
 8000308:	0800032c 	.word	0x0800032c
 800030c:	0800032c 	.word	0x0800032c
 8000310:	08000330 	.word	0x08000330

08000314 <_init>:
 8000314:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000316:	bf00      	nop
 8000318:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800031a:	bc08      	pop	{r3}
 800031c:	469e      	mov	lr, r3
 800031e:	4770      	bx	lr

08000320 <_fini>:
 8000320:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000322:	bf00      	nop
 8000324:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8000326:	bc08      	pop	{r3}
 8000328:	469e      	mov	lr, r3
 800032a:	4770      	bx	lr
